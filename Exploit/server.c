#include <stdio.h>
#include "hacking-network.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <arpa/inet.h>
#include "hacking.h"
#include "server.h"

#define WEBROOT "./webroot"

static int read_file(char * filename, char *, int );

int spawn_server(void)
{
	int sock = socket(2,1,0);
	sock_addr_in mysock_addr;
	
	mysock_addr.sin_family = AF_INET;
	mysock_addr.sin_port = htons(PORT);

	mysock_addr.sin_addr.s_addr = htonl(INADDR_ANY);// HOST;
	memset(&(mysock_addr.sin_zero),'\0',8);

	if(bind(sock, (sock_addr *)&mysock_addr, sizeof(sock_addr)) == -1)
		fatal("in spawn_server bind call");
	if(listen(sock, 5) == -1)
		fatal("in spawn_server listen call");

	return sock;
}
void handle_accept(int sock)
{
	int clientfd, size_client = sizeof(sock_addr_in); // client socket file descriptor and size
	sock_addr_in client_addr;
	puts("Waiting for connection");

	while(true) // accept connection loop
	{
		if((clientfd = accept(sock,(sock_addr *)&client_addr, &size_client)) == -1) 
			fatal("in handle_accept: accept call");

		handle_connection(clientfd, (sock_addr_in *)&client_addr);
	}
}

void handle_connection(int sockfd, sock_addr_in* client_addr_ptr)
{
	unsigned char *ptr, request[500], resource[500];
	int fd, length;
	length = recv_line(sockfd, request);

	printf("Got request from %s:%d \"%s\"\n", inet_ntoa(client_addr_ptr->sin_addr),
	ntohs(client_addr_ptr->sin_port), request);
	ptr = strstr(request, " HTTP/"); // Search for valid-looking request.

	if(ptr == NULL) { // Then this isn't valid HTTP.
		printf(" NOT HTTP!\n");
	} else {
		*ptr = 0; // Terminate the buffer at the end of the URL.
		ptr = NULL; // Set ptr to NULL (used to flag for an invalid request).
		if(strncmp(request, "GET ", 4) == 0) // GET request
	
		ptr = request+4; // ptr is the URL.
		if(strncmp(request, "HEAD ", 5) == 0) // HEAD request
			ptr = request+5; // ptr is the URL.
		if(ptr == NULL) { // Then this is not a recognized request.
			printf("\tUNKNOWN REQUEST!\n");
		} else { // Valid request, with ptr pointing to the resource name
		
			if (ptr[strlen(ptr) - 1] == '/') // For resources ending with '/',
				strcat(ptr, "index.html"); // add 'index.html' to the end.
			strcpy(resource, WEBROOT); // Begin resource with web root path
			strcat(resource, ptr); // and join it with resource path.

			fd = open(resource, O_RDONLY, 0); // Try to open the file.
			printf("\tOpening \'%s\'\t", resource);
		
			if(fd == -1) { // If file is not found
				printf(" 404 Not Found\n");
				send_string(sockfd, "HTTP/1.0 404 NOT FOUND\r\n");
				send_string(sockfd, "Server: Experimental server\r\n\r\n");
			
				send_string(sockfd, "<html><head><title>404 Not Found</title></head>");
				send_string(sockfd, "<body><h1>URL not found</h1></body></html>\r\n");
			} else { // Otherwise, serve up the file.
				printf(" 200 OK\n");
				send_string(sockfd, "HTTP/1.0 200 OK\r\n");
				send_string(sockfd, "Server: Experimental server\r\n\r\n");
				if(ptr == request + 4) { // Then this is a GET request
					if( (length = get_file_size(fd)) == -1)
						fatal("getting resource file size");
					if( (ptr = (unsigned char *) malloc(length)) == NULL)
						fatal("allocating memory for reading resource");
			
					read(fd, ptr, length); // Read the file into memory.
					send(sockfd, ptr, length, 0); // Send it to socket.
				}
				free(ptr); // Free file memory.
		
			}
				close(fd); // Close the file.
		} // End if block for file found/not found.
		//} // End if block for valid request.
	} // End if block for valid HTTP.
	shutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.
}



int serve_file(int client, char *buffer)
{
	int sent, remaining;
	remaining = strlen(buffer);

	while(remaining > 0)
	{
		sent = send(client, buffer, remaining, 0);
		if(sent == -1)
			fatal("in serve_file: on send call");
		
		remaining -= sent;
		buffer += sent;
	}
	
	puts("Done");
	return 0;	
}

int recv_request(int client, char *req_buffer, int req_size)
{
	int track = 0;
	char *track_buff = req_buffer + req_size;

/*	const char *EOL = "\r\n";
//	const int EOL_SIZE = 2;
	
	while((recv(client, req_buffer, 1, 0)) == 1 && req_buffer < track_buff)
	{
		if(*req_buffer == EOL[track])
		{
			track++;
			if(track == EOL_SIZE)
			{
				*(req_buffer + 1 - EOL_SIZE) = '\0';
				return strlen(req_buffer); // return size read
			}
		}
		else
			track = 0;
		req_buffer++;
	}*/

	return 0; // return if EOL not found
}

void mylog(sock_addr_in *client_addr)
{
	int logfd;
	logfd = open("Logfile.txt",O_RDONLY | O_WRONLY | O_CREAT);
	write(logfd, inet_ntoa(client_addr->sin_addr), sizeof(client_addr->sin_addr));
	close(logfd);
}

int get_file_size(int fd)
{
	struct stat stat_struct;
	if(fstat(fd, &stat_struct) == -1)
		return -1;
	return (int) stat_struct.st_size;
}

static int read_file(char * filename, char * buffer, int client)
{
	int fd;
		
	fd = open(filename, O_RDONLY, 0);
	if(fd == -1)
		return -1;

	int size = get_file_size(fd);
	buffer = (char *)malloc(size);

	read(fd ,buffer, size);
	if(buffer == NULL)
		fatal("in read_file: malloc call");
	
	serve_file(client,buffer);
	free(buffer);
	return size;
}
